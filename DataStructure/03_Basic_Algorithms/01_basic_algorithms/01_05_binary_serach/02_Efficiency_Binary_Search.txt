BS : O(logn), logn 是比較次數



2^h = n, n is array size, h is the steps

log2^h = logn
h = logn

=> O(h) = O(logn)


記得, O()都是講worst case, 真的看不出來的case 都用畫表格來看 array size vs 比較次數

bs 為例子
------------------------------------------
array size  |  0  |  1  |
------------------------------------------
compare step|  0  |  ?  |
------------------------------------------


假設 target value = 30, 故意找一個比array 最大的值, 才能顯出worst case

size = 1
[23], 30 > 23, 1 次就可以確定找不到
---------------------------------------------------------------------
array size  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |
---------------------------------------------------------------------
compare step|  0  |  1  |  ?  |
---------------------------------------------------------------------

size = 2
[2,4] 30>2, 往右看4 ,  30>4 結束 , 兩次
---------------------------------------------------------------------
array size  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |.......n
---------------------------------------------------------------------
compare step|  0  |  1  |  2  |  2  |  3  |  3  |  3  |  3  |  4  |.......h = 次數
---------------------------------------------------------------------

size 3
[2,6,8], 30>6, 30 > 8 , end 2次
size 4
[2,6,8,9], 30>6, 30 > 8, 30 > 9, 3次
size 5
[2,6,8,9,10], 30>8, 30 > 9, 30 > 10, 3次
size 6
[2,6,8,9,10,12], 30>8, 30 > 10, 30 > 12, 3次
size 7
[2,6,8,9,10,12,15], 30>9, 30 > 12, 30 > 15, 3次
size 8
[2,6,8,9,10,12,15,20], 30>9, 30 > 12, 30 > 15, 30>20 4次


上面表格可以看到
    compare step 改變的地方是在
    如果 array size 8 , 需要比較4次,
    如果 array size 4 , 需要比較3次,
    如果 array size 2 , 需要比較2次,
    如果 array size 1 , 需要比較1次,


-> 8 = 2^3 需要比較 3 + 1 次, 因此 n = 2^h, 需要比較 h +1 次
(或你可看成 array 從 8 個元素, 每次減少一半, 需要三次, 元素剩下1個 8*(1/2)^3 = 1
 所以, n *(1/2)^h = 1. 移項, n = 2^h)



Time complexity 就是比較的次數 O(h+1), 現在想求 h, n=2^h, logn = h,
帶入 O(logn +1) = O(logn)






##################
# Time complexity form T(n) of view
##################
    T(n) = T(n/2) + 1,
        T(n/2) is because we put the half array to next recursive call,
        1 is for comparison > or <

    Drop 1, and derivate the T(n)


    T(n)   = T(n/2) + 1
    T(n/2) = T(n/4) + 1
    ....
    T(1)   = constant K0



    so,

    T(n) = T(n/2) + 1
         = {T(n/4) +1 }  + 1 = T(n/4) + 2
         = {T(n/8) +1 }  + 2 = T(n/8) + 3
            .....
         = T(n/2^h) + h

    h is the height of binary tree
    n/2^h = 1, n=2^h, logn =h

    So,

    T(n) = T(1) + logn
         = K0 + logn
         = logn

    ***Thus, T(n) = O(logn)
